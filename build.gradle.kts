import com.google.gson.JsonElement
import com.google.gson.JsonParser

plugins {
    `java-library`
    `maven-publish`
    idea
    alias(libs.plugins.neoforged)
    alias(libs.plugins.kotlin.jvm)
}

version = libs.versions.mod.get()
group = "dev.echoellet"

val modGroupId = group as String
val modId = "dragonfist_legacy"
val modVersion = version as String
val neoVersion = libs.versions.neoforge.get()
val mcVersion = libs.versions.minecraft.get()
val javaVersion = libs.versions.java.get().toInt()

val generationTaskGroup = "generation"

repositories {
    mavenLocal()
    exclusiveContent {
        forRepository {
            maven {
                name = "Kotlin for Forge"
                url = uri("https://thedarkcolour.github.io/KotlinForForge/")
            }
        }
        filter { includeGroup("thedarkcolour") }
    }

    // Modrinth maven: https://support.modrinth.com/en/articles/8801191-modrinth-maven
    exclusiveContent {
        forRepository {
            maven {
                name = "Modrinth"
                url = uri("https://api.modrinth.com/maven")
            }
        }
//        forRepositories(fg.repository) // For ForgeGradle (Forge 1.20.1)
        filter {
            includeGroup("maven.modrinth")
        }
    }
}

base {
    archivesName.set(modId)
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(javaVersion))
    }
}

kotlin {
    jvmToolchain(javaVersion)
}

neoForge {
    version = neoVersion

    parchment {
        mappingsVersion.set(libs.versions.parchmentMappingsVersion.get())
        minecraftVersion.set(mcVersion)
    }

    // This line is optional. Access Transformers are automatically detected
    // accessTransformers.add('src/main/resources/META-INF/accesstransformer.cfg')
    runs {

        create("client") {
            client()

            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("server") {
            server()
            programArgument("--nogui")
            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("gameTestServer") {
            type = "gameTestServer"
            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("data") {
            data()

            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            programArguments.addAll(
                "--mod", modId,
                "--all",
                "--output", file("src/generated/resources/").absolutePath,
                "--existing", file("src/main/resources/").absolutePath
            )
        }
        // applies to all the run configs above
        configureEach {
            // Recommended logging data for a userdev environment
            // The markers can be added/remove as needed separated by commas.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            systemProperty("forge.logging.markers", "REGISTRIES")

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        // define mod <-> source bindings
        // these are used to tell the game which sources are for which mod
        // mostly optional in a single mod project
        // but multi mod projects should define one per mod
        register(modId) {
            sourceSet(sourceSets.main.get())
        }
    }
}

// Include resources generated by data generators.
sourceSets.main {
    resources.srcDir(layout.projectDirectory.dir("src/generated/resources"))
}

dependencies {
    implementation(libs.kotlinforforge)

    // compileOnly "mezz.jei:jei-${mc_version}-common-api:${jei_version}"
    // compileOnly "mezz.jei:jei-${mc_version}-forge-api:${jei_version}"
    // runtimeOnly "mezz.jei:jei-${mc_version}-forge:${jei_version}"

    implementation(libs.epicfight)
    implementation(libs.epicfight.skilltree)

    testImplementation(libs.kotlin.test)
}

tasks.test {
    useJUnitPlatform()
}

val generateModMetadata by tasks.registering(ProcessResources::class) {
    group = generationTaskGroup

    val replaceProperties = mapOf(
        "minecraft_version" to mcVersion,
        "minecraft_version_range" to libs.versions.minecraftVersionRange.get(),
        "neo_version" to neoVersion,
        "neo_version_range" to libs.versions.neoVersionRange.get(),
        "loader_version_range" to libs.versions.loaderVersionRange.get(),
        "mod_id" to modId,
        "mod_version" to modVersion
    )
    inputs.properties(replaceProperties)
    val targets = listOf(
        "META-INF/mods.toml", // Forge 1.20.1
        "META-INF/neoforge.mods.toml"
    )

    filesMatching(targets) {
        expand(replaceProperties)
    }
    from(layout.projectDirectory.dir("src/main/templates")) {
        include("META-INF/*.toml")
    }
    into(layout.buildDirectory.dir("generated/$name/src/main/resources"))
}

sourceSets.main {
    resources.srcDir(generateModMetadata.map { it.outputs.files.singleFile })
}
// To avoid having to run "generateModMetadata" manually, make it run on every project reload
neoForge.ideSyncTask(generateModMetadata)

// Example configuration to allow publishing using the maven-publish plugin
publishing {
    publications {
        register<MavenPublication>("mavenJava") {
            from(components["java"])
        }
    }
    repositories {
        maven {
            url = uri("${project.projectDir}/repo")
        }
    }
}

idea {
    module {
        isDownloadSources = true
        isDownloadJavadoc = true
    }
}

fun getGeneratedPackageName() = "$group.$modId.generated"

fun getModAssetsDirPath() = "src/main/resources/assets/$modId"
fun getGenOutputDirPath(taskName: String) = "generated/$taskName/src/main/kotlin"

val generateModAssetPaths = tasks.register("generateModAssetPaths") {
    group = generationTaskGroup
    description = "Generates Kotlin object represents the mod asset paths for type-safety"

    val taskName = name

    val inputDir = layout.projectDirectory.dir(getModAssetsDirPath())
    val outputDir = layout.buildDirectory.dir(getGenOutputDirPath(taskName))

    inputs.dir(inputDir).withPathSensitivity(PathSensitivity.RELATIVE)
    outputs.dir(outputDir)

    val className = "ModAssetPaths"
    val generatedPackageName = getGeneratedPackageName()

    doLast {
        val modAssetsDir = inputDir.asFile

        if (!modAssetsDir.exists()) return@doLast

        val constants = mutableListOf<String>()

        fun walkAssets(dir: File, relativePath: String = "") {
            dir.listFiles()?.forEach { file ->
                if (file.isDirectory) {
                    walkAssets(file, "$relativePath${file.name}/")
                } else {
                    val name = file.name
                    val constName = (relativePath + name)
                        .replace("[^A-Za-z0-9]".toRegex(), "_")
                        .uppercase()
                    val value = "$relativePath${name}"
                    constants += "    const val $constName = \"$value\""
                }
            }
        }

        walkAssets(modAssetsDir)

        val classFile = outputDir.get().asFile.resolve("$className.kt")

        classFile.apply {
            parentFile.mkdirs()
            writeText(
                """
                |package $generatedPackageName
                |
                | // Generated code, don't modify directly. Update the task "$taskName" in build.gradle.kts if needed.
                |object $className {
                |${constants.joinToString("\n")}
                |}
            """.trimMargin()
            )
        }

        println("Generated `$className`: ${classFile.path}")
    }
}

val generateLangKeys = registerKeyConstantsFromJsonFileTask(
    name = "generateLangKeys",
    inputFilePath = "${getModAssetsDirPath()}/lang/en_us.json",
    outputClassName = "LangKeys",
    taskDescription = "Generates Kotlin object represents the translation keys from en_us.json for type-safety"
)

val generateSoundNames = registerKeyConstantsFromJsonFileTask(
    name = "generateSoundNames",
    inputFilePath = "${getModAssetsDirPath()}/sounds.json",
    outputClassName = "SoundNames",
    taskDescription = "Generates Kotlin object represents the sound names from sounds.json for type-safety"
)

fun registerKeyConstantsFromJsonFileTask(
    name: String,
    inputFilePath: String,
    outputClassName: String,
    taskDescription: String
): TaskProvider<Task> {
    val task = tasks.register(name) {
        group = generationTaskGroup
        description = taskDescription

        val taskName = name

        val inputFile = layout.projectDirectory.file(inputFilePath)
        val outputDir = layout.buildDirectory.dir(getGenOutputDirPath(taskName))

        inputs.file(inputFile)
        outputs.dir(outputDir)

        val generatedPackageName = getGeneratedPackageName()

        // Required for Gradle configuration caching; using `modId` directly inside `doLast` can cause the build to fail.
        val cachedModId = modId

        doLast {
            val enLangFile = inputFile.asFile
            if (!enLangFile.exists()) return@doLast

            fun parseKeys(file: File): Map<String, String> {
                val parser = JsonParser.parseString(file.readText())
                return parser.asJsonObject.entrySet().associate { (key, _) ->
                    val constName = key
                        // Remove mod id if present
                        .replace(".$cachedModId", "", ignoreCase = true)
                        // Convert camelCase to snake_case
                        .replace(Regex("([a-z])([A-Z])"), "$1_$2")
                        .replace(".", "_")
                        .uppercase()

                    constName to key
                }
            }

            val constants = parseKeys(enLangFile)

            val generatedConstVals = constants.map { (constName, key) ->
                "    const val $constName = \"$key\""
            }

            val classFile = outputDir.get().asFile.resolve("$outputClassName.kt")
            classFile.parentFile.mkdirs()

            classFile.writeText(
                """
                |package $generatedPackageName
                |
                | // Generated code, don't modify directly. Update the task "$taskName" in build.gradle.kts if needed.
                |object $outputClassName {
                |${generatedConstVals.joinToString("\n")}
                |}
            """.trimMargin()
            )

            println("Generated `$outputClassName`: ${classFile.path}")
        }
    }
    return task
}

kotlin {
    sourceSets.main.get().kotlin.srcDir(generateModAssetPaths.map { it.outputs.files.singleFile })
    sourceSets.main.get().kotlin.srcDir(generateLangKeys.map { it.outputs.files.singleFile })
    sourceSets.main.get().kotlin.srcDir(generateSoundNames.map { it.outputs.files.singleFile })
}

tasks.compileKotlin {
    dependsOn(generateModAssetPaths)
    dependsOn(generateLangKeys)
    dependsOn(generateSoundNames)
}

tasks.register("formatJson") {
    // Note: This script was generated with the assistance of AI for minor maintenance tasks only.
    // It is intended for convenience and does not affect core functionality.

    group = "formatting"
    description = "Formats JSON files with custom inline/multiline rules"

    val maxInlineLength = 80
    val indentStep = "  "

    val filePaths = listOf(
        "src/main/resources/data/$modId/epicfight_mobpatch/shifu.json",
        "src/main/resources/data/$modId/epicfight_mobpatch/knight.json",
        "src/main/templates/epicfight_mobpatch/bandit_template.json",
    )

    doLast {

        fun formatJson(element: JsonElement, indentLevel: Int = 0): String {
            val indent = indentStep.repeat(indentLevel)
            return when {
                element.isJsonObject -> {
                    val obj = element.asJsonObject
                    val entries = obj.entrySet().map { (k, v) ->
                        "\"$k\": ${formatJson(v, indentLevel + 1)}"
                    }
                    val inline = "{ ${entries.joinToString(", ")} }"
                    if (inline.length <= maxInlineLength) inline
                    else {
                        val multiLine = entries.joinToString(",\n") { "${indentStep.repeat(indentLevel + 1)}$it" }
                        "{\n$multiLine\n$indent}"
                    }
                }

                element.isJsonArray -> {
                    val arr = element.asJsonArray
                    val items = arr.map { formatJson(it, indentLevel + 1) }
                    val inline = "[ ${items.joinToString(", ")} ]"
                    if (inline.length <= maxInlineLength) inline
                    else {
                        val multiLine = items.joinToString(",\n") { "${indentStep.repeat(indentLevel + 1)}$it" }
                        "[\n$multiLine\n$indent]"
                    }
                }

                element.isJsonPrimitive -> {
                    val prim = element.asJsonPrimitive
                    if (prim.isString) "\"${prim.asString}\"" else prim.toString()
                }

                element.isJsonNull -> "null"
                else -> element.toString()
            }
        }

        for (path in filePaths) {
            val file = File(path)
            if (!file.exists()) {
                println("\"$path\" not found!")
                continue
            }

            val jsonText = file.readText()
            val jsonElement = JsonParser.parseString(jsonText)
            val formatted = formatJson(jsonElement)
            file.writeText(formatted)
            println("Formatted JSON saved to $path")
        }
    }
}

// Keep in sync with the `BanditRank` enum in the source code.
// Each `entityId` must match the corresponding registered entity ID.
enum class BanditRank(val entityId: String) {
    Regular("bandit_regular"),
    Enforcer("bandit_enforcer"),
    Champion("bandit_champion"),
    Elite("bandit_elite"),
    Leader("bandit_leader"),
    Ruler("bandit_ruler");

    fun getAttributes(): EpicFightMobAttributes = when(this) {
        Regular -> EpicFightMobAttributes(impact = 0.4, chasingSpeed = 1.2)
        Enforcer -> EpicFightMobAttributes(impact = 0.425, maxStrikes = 2, armorNegation = 1.0, chasingSpeed = 1.235)
        Champion -> EpicFightMobAttributes(impact = 0.45, maxStrikes = 2, armorNegation = 2.0, chasingSpeed = 1.25)
        Elite -> EpicFightMobAttributes(impact = 0.455, maxStrikes = 3, scale = 1.050, armorNegation = 5.0, chasingSpeed = 1.275)
        Leader -> EpicFightMobAttributes(impact = 0.5, maxStrikes = 4, scale = 1.075, armorNegation = 10.0, chasingSpeed = 1.2)
        Ruler -> EpicFightMobAttributes(impact = 1.0, maxStrikes = 6, scale = 1.085, armorNegation = 20.0, chasingSpeed = 1.235)
    }
}

data class EpicFightMobAttributes(
    val impact: Double,
    val armorNegation: Double = 0.0,
    val maxStrikes: Int = 1,
    val chasingSpeed: Double = 1.0,
    val scale: Double = 1.0,
)

val generateBanditEpicFightMobPatchFiles = tasks.register("generateBanditEpicFightMobPatchFiles") {
    group = generationTaskGroup
    description = "Generates Bandit Epic Fight mob patch JSON files for different ranks from the same template."

    val taskName = name

    val inputDir = layout.projectDirectory.dir("src/main/templates/epicfight_mobpatch")
    val outputDir = layout.buildDirectory.dir("generated/$taskName/src/main/resources")

    inputs.dir(inputDir)
    outputs.dir(outputDir)

    // Required for Gradle configuration caching; using `modId` directly inside `doLast` can cause the build to fail.
    val cachedModId = modId

    doLast {
        val templateFile = inputDir.file("bandit_template.json").asFile
        val templateContent = templateFile.readText().lines()
            .filterNot { it.trimStart().startsWith("\"_comment\"") }
            .joinToString("\n")

        for (rank in BanditRank.values()) {

            fun String.replacePlaceholder(name: String, value: Any) = this.replaceFirst("\"\${$name}\"", value.toString())

            val outputFile = outputDir.get().file("data/$cachedModId/epicfight_mobpatch/${rank.entityId}.json").asFile
            val attributes = rank.getAttributes()
            val fileContent = templateContent
                .replacePlaceholder("impact", attributes.impact)
                .replacePlaceholder("armorNegation", attributes.armorNegation)
                .replacePlaceholder("maxStrikes", attributes.maxStrikes)
                .replacePlaceholder("chasingSpeed", attributes.chasingSpeed)
                .replacePlaceholder("scale", attributes.scale)

            outputFile.parentFile.mkdirs()
            outputFile.writeText(fileContent)
        }
    }
}

sourceSets.main {
    resources.srcDir(generateBanditEpicFightMobPatchFiles.map { it.outputs.files })
}

tasks.processResources {
    dependsOn(generateBanditEpicFightMobPatchFiles)
}
