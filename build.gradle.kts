import com.google.gson.JsonElement
import com.google.gson.JsonParser

plugins {
    `java-library`
    idea
    alias(libs.plugins.forgeGradle)
    alias(libs.plugins.parchmentForgeGradle)
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.spongepowered)
    alias(libs.plugins.modrinthMinotaur)
}

tasks.named<Wrapper>("wrapper") {
    distributionType = Wrapper.DistributionType.BIN
}

version = libs.versions.mod.get()
group = "dev.echoellet"

val modGroupId = group as String
val modId = "dragonfist_legacy"
val modVersion = version as String

val forgeVersion = libs.versions.forgeGradle.get()
val mcVersion = libs.versions.minecraft.get()
val javaVersion = libs.versions.java.get().toInt()

repositories {
    fun strictMaven(url: String, includeGroup: String, name: String) {
        exclusiveContent {
            forRepository {
                maven {
                    this.name = name
                    this.url = uri(url)
                }
            }
            forRepositories(fg.repository)
            filter {
                includeGroup(includeGroup)
            }
        }
    }
    // Kotlin for Forge maven: https://github.com/thedarkcolour/KotlinForForge
    strictMaven(
        url = "https://thedarkcolour.github.io/KotlinForForge/",
        name = "Kotlin for Forge",
        includeGroup = "thedarkcolour"
    )

    // Modrinth maven: https://support.modrinth.com/en/articles/8801191-modrinth-maven
    // Note: Prefer Maven repositories provided by the mod dependencies over Modrinth.
    strictMaven(
        url = "https://api.modrinth.com/maven",
        name = "Modrinth",
        includeGroup = "maven.modrinth"
    )

    // Curse Maven: https://www.cursemaven.com/
    // Note: Prefer Modrinth or Maven repositories provided by the mod dependencies over Curse Maven.
    strictMaven(
        url = "https://cursemaven.com",
        name = "CurseMaven",
        includeGroup = "curse.maven"
    )
}

base {
    archivesName.set(modId)
    version = "${modVersion}-mc${mcVersion}-forge"
}

java {
    withSourcesJar()
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(javaVersion))
    }
}

val sourcesJar by tasks.getting(Jar::class)

kotlin {
    jvmToolchain(javaVersion)
}

minecraft {
    mappings("parchment", "${libs.versions.parchmentMappings.get()}-${libs.versions.minecraft.get()}")

    copyIdeResources.set(true)

    runs {
        configureEach {
            workingDirectory = "run"
            property("forge.logging.markers", "REGISTRIES")
            property("forge.logging.console.level", "debug")

            mods {
                create(modId) {
                    source(sourceSets.main.get())
                }
            }
        }

        create("client") {
            property("forge.enabledGameTestNamespaces", modId)
        }

        create("server") {
            property("forge.enabledGameTestNamespaces", modId)
            args("--nogui")
        }

        create("gameTestServer") {
            property("forge.enabledGameTestNamespaces", modId)
        }

        create("data") {
            workingDirectory = "run-data"
            args(
                "--mod", modId,
                "--all",
                "--output", file("src/generated/resources/").absolutePath,
                "--existing", file("src/main/resources/").absolutePath
            )
        }
    }
}

// Include resources generated by data generators.
sourceSets.main {
    resources.srcDir(layout.projectDirectory.dir("src/generated/resources"))
}

configurations {
    val localRuntime by creating

    runtimeClasspath {
        extendsFrom(localRuntime)
    }
}

dependencies {
    minecraft("net.minecraftforge:forge:${libs.versions.minecraft.get()}-${libs.versions.forge.get()}")
    annotationProcessor("org.spongepowered:mixin:${libs.versions.spongepoweredProcessor.get()}:processor")

    val localRuntime by configurations.getting

    implementation(libs.kotlinforforge)

    implementation(fg.deobf(libs.epicfight.get()))
    implementation(fg.deobf(libs.epicFightSkillTree.get()))

    localRuntime(fg.deobf(libs.brutualbosses.get()))
    localRuntime(fg.deobf(libs.cupboard.get()))

    testImplementation(libs.kotlin.test)
}

tasks.test {
    useJUnitPlatform()
}

val generationTaskGroup = "generation"

val generateModMetadata by tasks.registering(ProcessResources::class) {
    group = generationTaskGroup

    val replaceProperties = mapOf(
        "minecraft_version_range" to libs.versions.minecraftRange.get(),
        "forge_version_range" to libs.versions.forgeRange.get(),
        "loader_version_range" to libs.versions.kotlinforforgeLoaderRange.get(),
        "epicfight_version_range" to libs.versions.epicfightRange.get(),
        "epicskills_version_range" to libs.versions.epicskillsRange.get(),
        "mod_id" to modId,
        "mod_version" to modVersion
    )
    inputs.properties(replaceProperties)
    val targets = listOf(
        "META-INF/mods.toml",
    )

    filesMatching(targets) {
        expand(replaceProperties)
    }
    from(layout.projectDirectory.dir("src/main/templates")) {
        include("META-INF/*.toml")
    }
    into(layout.buildDirectory.dir("generated/$name/src/main/resources"))
}

sourceSets.main {
    resources.srcDir(generateModMetadata.map { it.outputs.files.singleFile })
}

idea {
    module {
        isDownloadSources = true
        isDownloadJavadoc = true
    }
}

fun getGeneratedPackageName() = "$group.$modId.generated"

fun getModAssetsDirPath() = "src/main/resources/assets/$modId"
fun getGenOutputDirPath(taskName: String) = "generated/$taskName/src/main/kotlin"

val generateModAssetPaths = tasks.register("generateModAssetPaths") {
    group = generationTaskGroup
    description = "Generates Kotlin object represents the mod asset paths for type-safety"

    val taskName = name

    val inputDir = layout.projectDirectory.dir(getModAssetsDirPath())
    val outputDir = layout.buildDirectory.dir(getGenOutputDirPath(taskName))

    inputs.dir(inputDir).withPathSensitivity(PathSensitivity.RELATIVE)
    outputs.dir(outputDir)

    val className = "ModAssetPaths"
    val generatedPackageName = getGeneratedPackageName()

    doLast {
        val modAssetsDir = inputDir.asFile

        if (!modAssetsDir.exists()) return@doLast

        val constants = mutableListOf<String>()

        fun walkAssets(dir: File, relativePath: String = "") {
            dir.listFiles()?.forEach { file ->
                if (file.isDirectory) {
                    walkAssets(file, "$relativePath${file.name}/")
                } else {
                    val name = file.name
                    val constName = (relativePath + name)
                        .replace("[^A-Za-z0-9]".toRegex(), "_")
                        .uppercase()
                    val value = "$relativePath${name}"
                    constants += "    const val $constName = \"$value\""
                }
            }
        }

        walkAssets(modAssetsDir)

        val classFile = outputDir.get().asFile.resolve("$className.kt")

        classFile.apply {
            parentFile.mkdirs()
            writeText(
                """
                |package $generatedPackageName
                |
                | // Generated code, don't modify directly. Update the task "$taskName" in build.gradle.kts if needed.
                |object $className {
                |${constants.joinToString("\n")}
                |}
            """.trimMargin()
            )
        }

        println("Generated `$className`: ${classFile.path}")
    }
}

val generateLangKeys = registerKeyConstantsFromJsonFileTask(
    name = "generateLangKeys",
    inputFilePath = "${getModAssetsDirPath()}/lang/en_us.json",
    outputClassName = "LangKeys",
    taskDescription = "Generates Kotlin object represents the translation keys from en_us.json for type-safety"
)

val generateSoundNames = registerKeyConstantsFromJsonFileTask(
    name = "generateSoundNames",
    inputFilePath = "${getModAssetsDirPath()}/sounds.json",
    outputClassName = "SoundNames",
    taskDescription = "Generates Kotlin object represents the sound names from sounds.json for type-safety"
)

fun registerKeyConstantsFromJsonFileTask(
    name: String,
    inputFilePath: String,
    outputClassName: String,
    taskDescription: String
): TaskProvider<Task> {
    val task = tasks.register(name) {
        group = generationTaskGroup
        description = taskDescription

        val taskName = name

        val inputFile = layout.projectDirectory.file(inputFilePath)
        val outputDir = layout.buildDirectory.dir(getGenOutputDirPath(taskName))

        inputs.file(inputFile)
        outputs.dir(outputDir)

        val generatedPackageName = getGeneratedPackageName()

        // Required for Gradle configuration caching; using `modId` directly inside `doLast` can cause the build to fail.
        val cachedModId = modId

        doLast {
            val enLangFile = inputFile.asFile
            if (!enLangFile.exists()) return@doLast

            fun parseKeys(file: File): Map<String, String> {
                val parser = JsonParser.parseString(file.readText())
                return parser.asJsonObject.entrySet().associate { (key, _) ->
                    val constName = key
                        // Remove mod id if present
                        .replace(".$cachedModId", "", ignoreCase = true)
                        // Convert camelCase to snake_case
                        .replace(Regex("([a-z])([A-Z])"), "$1_$2")
                        .replace(".", "_")
                        .uppercase()

                    constName to key
                }
            }

            val constants = parseKeys(enLangFile)

            val generatedConstVals = constants.map { (constName, key) ->
                "    const val $constName = \"$key\""
            }

            val classFile = outputDir.get().asFile.resolve("$outputClassName.kt")
            classFile.parentFile.mkdirs()

            classFile.writeText(
                """
                |package $generatedPackageName
                |
                | // Generated code, don't modify directly. Update the task "$taskName" in build.gradle.kts if needed.
                |object $outputClassName {
                |${generatedConstVals.joinToString("\n")}
                |}
            """.trimMargin()
            )

            println("Generated `$outputClassName`: ${classFile.path}")
        }
    }
    return task
}

kotlin {
    sourceSets.main.get().kotlin.srcDir(generateModAssetPaths.map { it.outputs.files.singleFile })
    sourceSets.main.get().kotlin.srcDir(generateLangKeys.map { it.outputs.files.singleFile })
    sourceSets.main.get().kotlin.srcDir(generateSoundNames.map { it.outputs.files.singleFile })
}

tasks.compileKotlin {
    dependsOn(generateModAssetPaths)
    dependsOn(generateLangKeys)
    dependsOn(generateSoundNames)
}

tasks.register("formatJson") {
    // Note: This script was generated with the assistance of AI for minor maintenance tasks only.
    // It is intended for convenience and does not affect core functionality.

    group = "formatting"
    description = "Formats JSON files with custom inline/multiline rules"

    val maxInlineLength = 80
    val indentStep = "  "

    val filePaths = listOf(
        "src/main/resources/data/$modId/epicfight_mobpatch/shifu.json",
        "src/main/resources/data/$modId/epicfight_mobpatch/knight.json",
        "src/main/templates/epicfight_mobpatch/bandit_template.json",
    )

    doLast {

        fun formatJson(element: JsonElement, indentLevel: Int = 0): String {
            val indent = indentStep.repeat(indentLevel)
            return when {
                element.isJsonObject -> {
                    val obj = element.asJsonObject
                    val entries = obj.entrySet().map { (k, v) ->
                        "\"$k\": ${formatJson(v, indentLevel + 1)}"
                    }
                    val inline = "{ ${entries.joinToString(", ")} }"
                    if (inline.length <= maxInlineLength) inline
                    else {
                        val multiLine = entries.joinToString(",\n") { "${indentStep.repeat(indentLevel + 1)}$it" }
                        "{\n$multiLine\n$indent}"
                    }
                }

                element.isJsonArray -> {
                    val arr = element.asJsonArray
                    val items = arr.map { formatJson(it, indentLevel + 1) }
                    val inline = "[ ${items.joinToString(", ")} ]"
                    if (inline.length <= maxInlineLength) inline
                    else {
                        val multiLine = items.joinToString(",\n") { "${indentStep.repeat(indentLevel + 1)}$it" }
                        "[\n$multiLine\n$indent]"
                    }
                }

                element.isJsonPrimitive -> {
                    val prim = element.asJsonPrimitive
                    if (prim.isString) "\"${prim.asString}\"" else prim.toString()
                }

                element.isJsonNull -> "null"
                else -> element.toString()
            }
        }

        for (path in filePaths) {
            val file = File(path)
            if (!file.exists()) {
                println("\"$path\" not found!")
                continue
            }

            val jsonText = file.readText()
            val jsonElement = JsonParser.parseString(jsonText)
            val formatted = formatJson(jsonElement)
            file.writeText(formatted)
            println("Formatted JSON saved to $path")
        }
    }
}

// Keep in sync with the `BanditRank` enum in the source code.
// Each `entityId` must match the corresponding registered entity ID.
enum class BanditRank(val entityId: String) {
    Regular("bandit_regular"),
    Enforcer("bandit_enforcer"),
    Champion("bandit_champion"),
    Elite("bandit_elite"),
    Leader("bandit_leader"),
    Ruler("bandit_ruler");

    fun getAttributes(): EpicFightMobAttributes = when (this) {
        Regular -> EpicFightMobAttributes(impact = 0.4, chasingSpeed = 1.2)
        Enforcer -> EpicFightMobAttributes(impact = 0.425, maxStrikes = 2, armorNegation = 1.0, chasingSpeed = 1.235)
        Champion -> EpicFightMobAttributes(impact = 0.45, maxStrikes = 2, armorNegation = 2.0, chasingSpeed = 1.25)
        Elite -> EpicFightMobAttributes(
            impact = 0.455,
            maxStrikes = 3,
            scale = 1.050,
            armorNegation = 5.0,
            chasingSpeed = 1.275
        )

        Leader -> EpicFightMobAttributes(
            impact = 0.5,
            maxStrikes = 4,
            scale = 1.075,
            armorNegation = 10.0,
            chasingSpeed = 1.2
        )

        Ruler -> EpicFightMobAttributes(
            impact = 1.0,
            maxStrikes = 6,
            scale = 1.085,
            armorNegation = 20.0,
            chasingSpeed = 1.235
        )
    }
}

data class EpicFightMobAttributes(
    val impact: Double,
    val armorNegation: Double = 0.0,
    val maxStrikes: Int = 1,
    val chasingSpeed: Double = 1.0,
    val scale: Double = 1.0,
)

val generateBanditEpicFightMobPatchFiles = tasks.register("generateBanditEpicFightMobPatchFiles") {
    group = generationTaskGroup
    description = "Generates Bandit Epic Fight mob patch JSON files for different ranks from the same template."

    val taskName = name

    val inputDir = layout.projectDirectory.dir("src/main/templates/epicfight_mobpatch")
    val outputDir = layout.buildDirectory.dir("generated/$taskName/src/main/resources")

    inputs.dir(inputDir)
    outputs.dir(outputDir)

    // Required for Gradle configuration caching; using `modId` directly inside `doLast` can cause the build to fail.
    val cachedModId = modId

    doLast {
        val templateFile = inputDir.file("bandit_template.json").asFile
        val templateContent = templateFile.readText().lines()
            .filterNot { it.trimStart().startsWith("\"_comment\"") }
            .joinToString("\n")

        for (rank in BanditRank.values()) {

            fun String.replacePlaceholder(name: String, value: Any) =
                this.replaceFirst("\"\${$name}\"", value.toString())

            val outputFile = outputDir.get().file("data/$cachedModId/epicfight_mobpatch/${rank.entityId}.json").asFile
            val attributes = rank.getAttributes()
            val fileContent = templateContent
                .replacePlaceholder("impact", attributes.impact)
                .replacePlaceholder("armorNegation", attributes.armorNegation)
                .replacePlaceholder("maxStrikes", attributes.maxStrikes)
                .replacePlaceholder("chasingSpeed", attributes.chasingSpeed)
                .replacePlaceholder("scale", attributes.scale)

            outputFile.parentFile.mkdirs()
            outputFile.writeText(fileContent)
        }
    }
}

sourceSets.main {
    resources.srcDir(generateBanditEpicFightMobPatchFiles.map { it.outputs.files })
}

tasks.processResources {
    dependsOn(generateBanditEpicFightMobPatchFiles)
    dependsOn(generateModMetadata)
}
